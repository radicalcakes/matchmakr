import os.path
import tornado.auth
import tornado.escape
import tornado.httpserver
import tornado.ioloop
import tornado.options
import tornado.web
import tornado.log
import tornado.gen
import tornadoredis
from facebook import GraphAPI


from tornado.escape import to_unicode, json_decode, native_str, json_encode
import random

from tornado.options import define, options

define("port", default=1935, help="run on the given port", type=int)
define("facebook_api_key", help="API key",
       default="451844331561292")
define("facebook_secret", help="Facebook application secret",
       default="86938626051ad850ca9b758ef8b0c258")


#should get object from mainhandler and store to redis, but for test purposes, we'll just use minehandler for that now

class Application(tornado.web.Application):
    def __init__(self):
        handlers = [
            (r"/", IndexHandler),
	        (r"/main", MainHandler),
            (r"/love", PartnerHandler),
            (r"/auth/login", AuthLoginHandler),
            (r"/auth/logout", AuthLogoutHandler),
        ]
        settings = dict(
            cookie_secret="fdkfadsljdfklsjkladfsjkldfsajklj8((@*&#jlitjuu#$%i99#@G",
            login_url="/auth/login",
            template_path=os.path.join(os.path.dirname(__file__), "templates"),
            static_path=os.path.join(os.path.dirname(__file__), "static"),
            xsrf_cookies=True,
            facebook_api_key=options.facebook_api_key,
            facebook_secret=options.facebook_secret,
            ui_modules={"Partner":PartnerModule},
            debug=True,
            autoescape=None,
        )
        tornado.web.Application.__init__(self, handlers, **settings)


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render("index.html")


class BaseHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        user_json = self.get_secure_cookie("fbdemo_user")
        if not user_json: return None
        return tornado.escape.json_decode(user_json)

    @tornado.gen.engine
    def user_exists(self, curr):
        c = tornadoredis.Client()
        c.connect()
        yield tornado.gen.Task(c.hget, "users:%s" % str(curr["id"]), "name")



class AuthLoginHandler(BaseHandler, tornado.auth.FacebookGraphMixin):
    @tornado.web.asynchronous
    def get(self):
        my_url = (self.request.protocol + "://" + self.request.host +
                  "/auth/login?next=" +
                  tornado.escape.url_escape(self.get_argument("next", "/")))
        if self.get_argument("code", False):
            self.get_authenticated_user(
                redirect_uri=my_url,
                client_id=self.settings["facebook_api_key"],
                client_secret=self.settings["facebook_secret"],
                code=self.get_argument("code"),
                callback=self._on_auth)
            return
        self.authorize_redirect(redirect_uri=my_url,
                                client_id=self.settings["facebook_api_key"],
                                extra_params={"scope": "read_stream, user_about_me,user_interests,friends_activities,friends_birthday,friends_education_history,friends_interests,friends_likes,friends_relationships,friends_relationship_details,friends_religion_politics,friends_subscriptions,friends_events,friends_status friends_about_me, offline_access,read_friendlists,user_likes,user_activities,user_relationships,user_relationship_details, friends_photos,user_photos"})

    def _on_auth(self, user):
        if not user:
            raise tornado.web.HTTPError(500, "Facebook auth failed")
        self.set_secure_cookie("fbdemo_user", tornado.escape.json_encode(user))
        self.redirect(self.get_argument("next", "/"))


class AuthLogoutHandler(BaseHandler, tornado.auth.FacebookGraphMixin):
    def get(self):
        self.clear_cookie("fbdemo_user")
        self.redirect(self.get_argument("next", "/"))


#all user based magic happens here
class MainHandler(BaseHandler, tornado.auth.FacebookGraphMixin):
    @tornado.gen.engine
    @tornado.web.authenticated
    @tornado.web.asynchronous
    def get(self):
        c = tornadoredis.Client()
        c.connect()
        user = yield tornado.gen.Task(c.hget, "users:%s" % self.current_user["id"], "name")
        interest = yield tornado.gen.Task(c.hget, "users:%s"% self.current_user["id"], "interested_in")
        if len(user) > 2:
            self.show_radio(interest)
            print self.current_user["name"] + " connected"
        else:
            self.facebook_request("/me", self.make_user,
                              access_token=self.current_user["access_token"])
            print self.current_user["name"] + " connected"
            self.show_radio(interest)

    def show_radio(self, interest):
        if "u'male'" or "u'female'" in interest:
            print "specified"
            self.render("index.html", interest=interest)
        else:
            interest = False
            self.render("index.html", interest=interest)

    @tornado.web.asynchronous
    @tornado.gen.engine
    def post(self):
        self.interested_in = self.get_argument('optionsRadios')
        c = tornadoredis.Client()
        c.connect()
        with c.pipeline() as pipe:
            print self.interested_in
            pipe.hset("users:%s" % self.current_user["id"], "interested_in", self.interested_in)
            yield tornado.gen.Task(pipe.execute)
        print "updated interested in"
        self.render("index.html", interest=self.interested_in)

    def make_user(self, d):
        new = {"name":d["name"]}
        if 'interested_in' and 'gender' in d:
            new["gender"] = d["gender"]
            new["interested_in"] = d["interested_in"]
            self.get_likes()
            create_user(d, new)
        elif 'interested_in' in d:
            new["gender"] = None
            new["interested_in"] = d["interested_in"]
            self.get_likes()
            create_user(d, new)
        elif 'gender' in d:
            new["gender"] = d["gender"]
            new["interested_in"] = None
            self.get_likes()
            create_user(d, new)

    @tornado.web.asynchronous
    def get_likes(self):
        self.facebook_request("/me", self.parse_likes, access_token=self.current_user["access_token"], fields="movies.fields(id),music.fields(id),favorite_athletes,favorite_teams,religion,political,sports,books.fields(id),games.fields(id),interests.fields(id),television.fields(id),activities.fields(id)")

    @tornado.gen.engine
    def parse_likes(self, d):
        c = tornadoredis.Client()
        c.connect()
        i = d.itervalues()
        with c.pipeline() as pipe:
            for e in i:
                if 'data' in e:
                    for j in e["data"]:
                        pipe.lpush("user:%s" % d["id"], j["id"])
                elif type(e) == list:
                    for h in e:
                        pipe.lpush("user:%s" % d["id"], h["id"])
            print "posted to redis"
            yield tornado.gen.Task(pipe.execute)


class PartnerHandler(BaseHandler, tornado.auth.FacebookGraphMixin):
    @tornado.web.authenticated
    @tornado.gen.engine
    def get(self):
        """
        c = tornadoredis.Client()
        c.connect()
        check = yield tornado.gen.Task(c.hget, "users:%s" % self.current_user["id"], "checked")
        if check == "True":
            print "already calculated"
        elif check != "True":
            with c.pipeline() as pipe:
                pipe.hset("users:%s" % self.current_user["id"], "checked", "True")
                yield tornado.gen.Task(pipe.execute)
        """
        #self.facebook_request("/me", self.get_friends,
                    #access_token=self.current_user["access_token"], fields="friends.fields(id,name,interested_in,relationship_status,gender)")
        self.facebook_request("/me",self.get_sports, access_token = self.current_user["access_token"], fields="friends.fields(favorite_teams,favorite_athletes,sports)")
            #self.facebook_request("/me",self.get_books_games, access_token = self.current_user["access_token"], fields="friends.fields(games,books)")
        self.facebook_request("/me",self.get_movies_interests, access_token = self.current_user["access_token"], fields="friends.fields(interests,movies)")
        self.facebook_request("/me",self.get_music, access_token = self.current_user["access_token"], fields="friends.fields(music)")


    def set_tv(self):
            self.facebook_request("/me", self.get_tv, access_token = self.current_user["access_token"], fields="friends.fields(television)")

    #move to get so no need to recalc every single time
    @tornado.gen.engine
    def get_friends(self,d):
        for i in d["friends"]["data"]:
            if "relationship_status" not in i:
                create_person(i)
            else:
                rel = i["relationship_status"]
                if rel == "Married" or rel == "In a Relationship":
                    continue
                elif rel == "Single" or rel == "It's Complicated":
                    create_person(i)
        print "fired"

    def get_sports(self,d):
        set_base_data(d, "favorite_teams", "favorite_athletes", "sports")
        print "sports fired"

    def get_books_games(self,d):
        set_connect_data(d, "games", "books")
        print "books fired"

    def get_movies_interests(self,d):
        set_connect_data(d, "movies", "interests")
        print "movies fired"

    def get_music(self,d):
        set_connect_data(d, "music")
        print "music fired"

    def get_tv(self,d):
        set_connect_data(d, "television")
        print "tv fired"

    #get top 50 people add to rank
    @tornado.gen.engine
    def ready_data(self):
        c = tornadoredis.Client()
        c.connect()
        interest = yield tornado.gen.Task(c.hget,"users:%s" % self.current_user["id"], "interested_in")
        u_likes = yield tornado.gen.Task(c.lrange,"user:%s" % self.current_user["id"], 0, -1)
        print u_likes, type(interest)

    def calculate_data(self, likes, *interests):
        pass

    def return_data(self, c):
        self.finish()
        pass



class PartnerModule(tornado.web.UIModule):
    def render(self, partner):
        return self.render_string("modules/partner.html", partner=partner)



@tornado.gen.engine
def create_person(n):
    c = tornadoredis.Client()
    c.connect()
    with c.pipeline() as pipe:
        pipe.hmset("people:%s" % n["id"], n)
        yield tornado.gen.Task(pipe.execute)
    print "added person"


@tornado.gen.engine
def set_base_data(d, *args):
    c = tornadoredis.Client()
    c.connect()
    with c.pipeline() as pipe:
        for e in d["friends"]["data"]:
            for key in args:
                if key in e:
                    user_gender = yield tornado.gen.Task(c.hget,"people:%s" % e["id"], "gender")
                    for s in e[key]:
                        #print "likes:%s:%s:%s" %(s["id"],user_gender,s["name"])
                        pipe.sadd("likes:%s:%s:%s" %(s["id"],user_gender,s["name"]), e["id"])
        yield tornado.gen.Task(pipe.execute)
    print "added likes to redis"


@tornado.gen.engine
def set_connect_data(d, *args):
    c = tornadoredis.Client()
    c.connect()
    with c.pipeline() as pipe:
        for f in d["friends"]["data"]:
            for key in args:
                if key in f:
                    user_gender = yield tornado.gen.Task(c.hget,"people:%s" % f["id"], "gender")
                    for i in f[key]["data"]:
                        #print "likes:%s:%s:%s" %(i["id"],user_gender,i["name"])
                        pipe.sadd("likes:%s:%s:%s" %(i["id"],user_gender,i["name"]), f["id"])
        yield tornado.gen.Task(pipe.execute)
    print "added connect likes to redis"


@tornado.gen.engine
def create_user(d, n):
    c = tornadoredis.Client()
    c.connect()
    with c.pipeline() as pipe:
        pipe.hmset("users:%s" % (d["id"]), n)
        yield tornado.gen.Task(pipe.execute)
    print "Posted to redis"



def main():
    tornado.options.parse_command_line()
    http_server = tornado.httpserver.HTTPServer(Application())
    http_server.listen(options.port)
    tornado.ioloop.IOLoop.instance().start()


if __name__ == "__main__":
    main()
